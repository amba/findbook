#!/usr/bin/env perl
use 5.014;
use warnings;
use strict;
use utf8;
use Getopt::Long;
use Encode;
use File::Basename;
use Unicode::Normalize qw/NFD/;
#FIXME: --version option
# we prefer YAML::XS over YAML::Tiny
my $have_yaml_xs = 0;
eval 'use YAML::XS; $have_yaml_xs = 1; 1;'
    or eval 'use YAML::Tiny; 1'
    or die "error: no YAML module. See README for help.\n$@\n";

binmode STDOUT, ':encoding(UTF-8)';
binmode STDIN, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

my $prog_name = basename ($0);
my $fallback_viewer = "evince";
my $config_file = "$ENV{HOME}/.config/findbook.yml";
my $search_all_formats = 0;
my $case_sensitive = 0;
my $match_fixed_strings = 0;
my $match_paths = 0;
my $viewer;
my $help;

my $config;
my @dirs;
my $have_formats = 0;
my %format_hash;

# parse commandline

GetOptions ("viewer=s" => \$viewer,
	    "all-formats" => \$search_all_formats,
	    "case-sensitive|i" => \$case_sensitive,
	    "fixed-strings|F" => \$match_fixed_strings,
	    "paths" => \$match_paths,
	    "file=s" => \$config_file,
	    "help" => \$help)
    or exit 1;

if ($help) {
    state_help ();
    exit 0;
}

if ($#ARGV  == -1) {
    state_usage ();
    die "error: need at least one argument\n";
}

 
@ARGV = map NFD (decode ('utf8', $_)), @ARGV;

# read in and parse configuration file

$config = load_file ($config_file);

die "config file must be a mapping\n" if !(ref $config eq "HASH");

die "no search directory in config"  if !$config->{dirs};
die "value of 'dirs' must be a list" if !(ref $config->{dirs} eq "ARRAY");
@dirs = @{$config->{dirs}};
die "value of 'dirs' must be a non-empty list" if scalar @dirs < 1;

$fallback_viewer = $config->{"default-viewer"} if $config->{"default-viewer"};

if ($config->{formats}) {
    die "value of 'formats' must be a hash"
	if (!(ref $config->{formats} eq "HASH"));
    my %viewer_hash = %{$config->{formats}};
    for my $key (keys %viewer_hash) {
	for my $extension (@{$viewer_hash{$key}}) {
	    die "file format '$extension' listed more than once in" .
		" 'format' hash\n"
		if $format_hash{$extension};
	    $format_hash{$extension} = $key;
	}
    }
    $have_formats = scalar keys %format_hash;
    
}

my @files;

# glob for each file format

if ($have_formats && !$search_all_formats) {
    for my $format (keys %format_hash) {
	for my $directory (@dirs) {
	    push @files, glob ("\Q${directory}\E" . "/*" . "\Q${format}\E");
	}
    }
}
else {
    for my $directory (@dirs) {
	    push @files, glob ("\Q${directory}\E/*");
    }
}
# for each file we create a hashref with:
# filename: unmodified file path
# nfd_filename: canonical decomposition of filename;
# basename: basename of nfd_filename
@files = map decode ('UTF-8', $_), @files;
@files = map {
    my $nfd_filename = NFD ($_);
    {
	filename => $_,
	nfd_filename => $nfd_filename,
	basename => basename ($nfd_filename)
    };
} @files;

# setup regular expressions

if ($match_fixed_strings) {
    if ($case_sensitive) {
	@ARGV = map qr/\Q$_\E/, @ARGV;
    }
    else {
	@ARGV = map qr/\Q$_\E/i, @ARGV;
    }
}
else {
    eval {
	if ($case_sensitive) {
	    @ARGV = map qr/$_/, @ARGV;
	}
	else {
	    @ARGV = map qr/$_/i, @ARGV;
	}
    };
    die "invalid regex: $@" if $@;
}

# grep the list of filenames for each regexp
for my $regex (@ARGV) {
    @files = grep {
	if ($match_paths) {
	    $_->{nfd_filename} =~ /$regex/;
	}
	else {
	    $_->{basename} =~ /$regex/;
	}
    } @files;
}

die "error: no book found\n" if $#files == -1;

# check for duplicate basenames
my %duplicates;
my $have_duplicates = 0;
for (@files) {
    if ($duplicates{$_->{basename}}++) {
	$have_duplicates = 1;
	last;
    }
}

# present the list of matching files to the user

if ($have_duplicates) {
    
    say "[$_] ", $files[$_]{filename} for (0..$#files); 
}
else {    
    say "[$_] ", $files[$_]{basename} for (0..$#files); 
}

# get user input

my $input;
if ($#files == 0) {	# unique search result
    $input = 0;
}
else {
    say "press number 0-$#files or  q to quit";
    $input = <STDIN>;
    chomp($input);
    exit 0 if $input =~ /\Aq\Z/;
    $input = "0" if $input eq "";
    if ($input < 0 || $input > $#files) {
	die "error: number out of range\n";
    }
}

if (!$viewer) {
    # no command line option 'v' given.
    # search the format hash for a viewer.
    for my $format (keys %format_hash) {
	if ($files[$input]{filename} =~ /\Q$format\E$/) {
	    $viewer = $format_hash{$format}
	}
    }
    if (!$viewer) {
	$viewer = $fallback_viewer;
    }
}
my @command = ($viewer, $files[$input]{filename});
system_wrapper (@command);

sub system_wrapper {
    say "command: @_";
    system (@_) == 0
	or die "error: system failed: $?\n"
}

sub state_usage {
    say "Usage: $prog_name [OPTIONS] PATTERN1 [PATTERN2 ...]";
}

sub state_help {
    state_usage ();
        say "\nfind and view ebooks on your hard drive.\n
FIXME: explain PATTERNS
OPTIONS


  -a, --all-formats           list all file formats, not only those given in
                              the configuration file.
  -F, --fixed-strings         match against fixed strings, not regular
                              expressions.        
  -i, --case-sensitive        do not ignore case distinctions in filenames.
  -p, --paths                 match against full paths, not basenames.
  -v, --viewer=VIEWER         use VIEWER. overrides the config file.

  -f, --file=FILE             read configuration from FILE.
                              default: ~/.config/findbook.yml
  -h, --help                  give this help screen.

CONFIGURATION

#FIXME: see README
mandatory configuration file with contents like this:
-------------- ~/.config/findbook.yml --------------------
# fallback viewer, only relevant if commandline option 'a' is given, or if the 
# 'formats' hash (see below) is not given
default-viewer: evince  

# list of searched directories (mandatory)
dirs:
  - /home/simon/Bücher
  - /home/simon/Bücher/papers

# A list of file extensions for each viewer program
formats:
  evince:
    - .pdf
    - .djvu
  okular:
    - .epub
------------- end of ~/.config/findbook.yml -------------- 
";
}

# load YAML file
sub load_file {
    my $filename = shift;
    open my $fh, $filename
	or die "Cannot open '$filename' for input:\n$!\n";
    my $string = do { local $/; local $_ = <$fh>};
    
    if (!$have_yaml_xs) {
	# YAML::Tiny's Load needs a perl unicode string 
	$string = decode ('UTF-8', $string);
    }
    
    return Load ($string);
}
